## API Report File for "@lyonbot/linked-data"

> Do not edit this file. It is a report generated by [API Extractor](https://api-extractor.com/).

```ts

import { DefaultListener } from 'tiny-typed-emitter';
import { ListenerSignature } from 'tiny-typed-emitter';
import { TypedEmitter } from 'tiny-typed-emitter';

// @public
export type AnyObject = Record<string, any> | any[];

// @public
export function applyPatches(root: any, patches: PatchOp[]): any;

// Warning: (ae-forgotten-export) The symbol "ArraySchema_base" needs to be exported by the entry point index.d.ts
//
// @public
export class ArraySchema extends ArraySchema_base {
    // (undocumented)
    readonly $context: SchemaContext;
    // (undocumented)
    readonly $id: string;
    constructor($context: SchemaContext, $id: string, input: ArraySchemaDescriptor);
    get(key: null | undefined | string | number | (string | number)[]): Schema | null;
    // (undocumented)
    readonly items: Schema;
}

// @public (undocumented)
export interface ArraySchemaDescriptor {
    // (undocumented)
    items: string | SchemaDescriptor;
    // (undocumented)
    type: 'array';
}

// @public
export function castConstructor<T, T2, U extends any[]>(ctor: (this: T, ...x: U) => T2): new (...x: U) => T2 extends void ? T : T2;

// @public (undocumented)
export function cloneDeep(src: any, opts?: {
    freeze?: boolean;
}): any;

// @public (undocumented)
export class DataNode<T = any> {
    // @internal (undocumented)
    get [$getDataNode](): this;
    constructor(owner: LinkedData, id: string, schema: Schema | null);
    export(options?: {
        writeKey?: boolean | ((node: DataNode) => boolean);
    }): T;
    // (undocumented)
    readonly id: string;
    iterate(visitor: (node: DataNode, path: (string | number)[]) => void | 'abort' | 'skip'): void;
    // (undocumented)
    readonly owner: LinkedData;
    _proxy?: any;
    raw?: any;
    readonly ref: DataNodeRef;
    referedBy: Map<DataNode<any>, number>;
    refering: Map<DataNode<any>, number>;
    // (undocumented)
    readonly schema: Schema | null;
    setValue(value: T, importOptions?: LinkedDataImportOptions): void;
    setVoid(): void;
    // (undocumented)
    status: DataNodeStatus;
    get value(): T;
    set value(v: T);
}

// @public
export class DataNodeRef {
    constructor(owner: LinkedData, id: string);
    // (undocumented)
    addRef(fromNode: DataNode): void;
    // (undocumented)
    id: string;
    // (undocumented)
    get node(): DataNode<any>;
    // (undocumented)
    owner: LinkedData;
    // (undocumented)
    unref(fromNode: DataNode): void;
}

// @public (undocumented)
export const enum DataNodeStatus {
    // (undocumented)
    FILLED_WITH_ANY = 1,
    // (undocumented)
    FILLED_WITH_ARRAY = 4,
    // (undocumented)
    FILLED_WITH_OBJECT = 3,
    // (undocumented)
    FILLED_WITH_REF = 2,
    // (undocumented)
    VOID = 0
}

// @public
export interface DeletePatchOp extends PatchOpBase {
    // (undocumented)
    op: 'delete';
}

// @public
export function derive(src: any, patches: PatchOp[], options?: DeriveOptions): any;

// @public (undocumented)
export interface DeriveOptions {
    clone?: boolean;
    freeze?: boolean;
    onFinish?: (report: DeriveReport) => void;
}

// @public (undocumented)
export interface DeriveReport {
    // Warning: (ae-forgotten-export) The symbol "TrieNode" needs to be exported by the entry point index.d.ts
    //
    // (undocumented)
    mutated?: TrieNode<any>;
    // (undocumented)
    result: any;
}

// @public
export function dumpDataNodes(node: DataNode | null | undefined | Iterable<DataNode | null | undefined>, options?: {
    writeKey?: boolean;
}): {
    schemaIds: string[];
    nodeInfos: Record<string, DumpedNode>;
};

// @public (undocumented)
export interface DumpedNode {
    // (undocumented)
    id: string;
    // (undocumented)
    raw: any;
    // (undocumented)
    referredBy: {
        sourceNodeId: string;
        path: Path;
    }[];
    // (undocumented)
    refs: {
        path: Path;
        targetNodeId: string;
    }[];
    // (undocumented)
    schemaId: string | null;
}

// @public
export class EventEmitter<L extends ListenerSignature<L> = DefaultListener> extends TypedEmitter<L> {
    // (undocumented)
    subscribe<U extends keyof L>(event: U, listener: L[U]): () => void;
    // (undocumented)
    subscribeOnce<U extends keyof L>(event: U, listener: L[U]): () => void;
}

// @public (undocumented)
export function forEach(objOrArray: any, iter: (value: any, key: string | number, whole: any) => any): void;

// @public
export function fromJsonSafeRaw(safe: JSONSafeData, inflateRef: (id: string) => DataNodeRef | null): any;

// @public (undocumented)
export function get<T = any>(obj: any, path: (string | number)[]): T;

// @public (undocumented)
export const isDataNodeRef: (value: any) => value is DataNodeRef;

// @public
export function isObject(value: any): value is Record<string | number | symbol, any>;

// @public
export function isPlainObject(value: any): value is Record<string | number | symbol, any>;

// @public
export interface JSONSafeData {
    // (undocumented)
    raw: any;
    // (undocumented)
    refs: {
        path: Path;
        targetNodeId: string;
    }[];
}

// @public
export class LinkedData extends EventEmitter<LinkedDataEvents> {
    constructor(options: LinkedDataOptions);
    // (undocumented)
    allocateId(_ref?: any): string;
    // (undocumented)
    createVoidNode<T = any>(options: {
        id?: string;
        schema?: string | Schema | null;
        overwrite?: boolean;
    }): DataNode<T>;
    // (undocumented)
    getNode(id: string): DataNode<any> | undefined;
    import<T = any>(value: T, schema?: string | Schema | null, options?: LinkedDataImportOptions): DataNode<T>;
    // (undocumented)
    _nodes: Map<string, DataNode>;
    // (undocumented)
    schemas: SchemaContext;
}

// @public (undocumented)
export interface LinkedDataEvents {
    beforeChange(ev: {
        context: LinkedData;
        node: DataNode;
        object: AnyObject | '<root>';
        op: 'set' | 'delete';
        key?: string | number;
    }): any;
}

// @public (undocumented)
export interface LinkedDataImportOptions {
    overwrite?: 'same-schema' | 'always' | 'never' | ((data: any, existingNode: DataNode, schema: Schema) => boolean);
}

// @public (undocumented)
export interface LinkedDataOptions {
    // (undocumented)
    schemas?: Record<string, SchemaDescriptor | string> | SchemaContext;
}

// @public
export function loadDataNodes(destination: LinkedData, data: Iterable<DumpedNode> | Record<string, DumpedNode>, options?: {
    overwrite?: boolean;
}): Record<string, DataNode>;

// @public
export const makeDataClass: <T>() => new (x: T) => T extends void ? unknown : T;

// @public
export function makeGetterFromDictionary<T>(dict: Record<string, T>): (input: string | number | undefined | void | null) => T | undefined;

// @public
export function mapValues(objOrArray: any, mapper: (value: any, key: string | number, whole: any) => any): any;

// @public
export function memoWithWeakMap<T, U>(fn: (a: T) => U): {
    (a: T): U;
    clear(): void;
    delete(a: T): void;
    get(a: T): U | undefined;
};

// @public (undocumented)
export class ModificationObserver {
    // Warning: (ae-forgotten-export) The symbol "ModificationObserverCallback" needs to be exported by the entry point index.d.ts
    constructor(callback: ModificationObserverCallback);
    // (undocumented)
    clearBuffer(): void;
    // (undocumented)
    disconnect(): void;
    // (undocumented)
    observeLinkedData(ld: LinkedData | null | undefined): this;
    // (undocumented)
    observeNode(node: DataNode | null | undefined): this;
    takeRecords(keepBuffer?: boolean): ModificationRecord[];
}

// @public
export interface ModificationRecord {
    isNewNode?: boolean;
    node: DataNode;
    patches: PatchOp[];
    revertPatches: PatchOp[];
}

// Warning: (ae-forgotten-export) The symbol "ObjectSchema_base" needs to be exported by the entry point index.d.ts
//
// @public
export class ObjectSchema extends ObjectSchema_base {
    // (undocumented)
    readonly $context: SchemaContext;
    // (undocumented)
    readonly $id: string;
    constructor($context: SchemaContext, $id: string, input: ObjectSchemaDescriptor);
    // (undocumented)
    addProperties(properties: ObjectSchemaDescriptor['properties']): void;
    get(key: null | undefined | string | number | (string | number)[]): Schema | null;
    // (undocumented)
    readKey(raw: any): unknown | undefined;
    // (undocumented)
    removeProperties(keys: string[]): void;
    // (undocumented)
    setProperties(properties: ObjectSchemaDescriptor['properties']): void;
    // (undocumented)
    writeKey(dest: any, key: any): void;
}

// @public (undocumented)
export interface ObjectSchemaDescriptor {
    key?: string | {
        import: string | ((raw: any) => string | undefined | void);
        export: string | ((dest: any, id: string) => void);
    };
    // (undocumented)
    properties: Record<string, string | SchemaDescriptor>;
    // (undocumented)
    type: 'object';
}

// @public
export type PatchOp = SetPatchOp | DeletePatchOp | ResortArrayPatchOp;

// @public (undocumented)
export interface PatchOpBase {
    // (undocumented)
    op: string;
    // (undocumented)
    path: Path;
}

// @public
export type Path = (string | number)[];

// @public
export interface ResortArrayPatchOp extends PatchOpBase {
    // (undocumented)
    indexMap: number[];
    // (undocumented)
    op: 'resortArray';
}

// @public
export type Schema = ObjectSchema | ArraySchema;

// @public
export class SchemaContext {
    constructor(schemas?: Record<string, SchemaDescriptor | string>);
    get(query: string[] | string | SchemaDescriptor | Schema | null | undefined, via?: Schema, viaKey?: string | number): Schema | null;
    register(id: string, x: SchemaDescriptor | string): ObjectSchema | ArraySchema | undefined;
}

// @public (undocumented)
export type SchemaDescriptor = ObjectSchemaDescriptor | ArraySchemaDescriptor;

// @public
export interface SetPatchOp extends PatchOpBase {
    // (undocumented)
    op: 'set';
    // (undocumented)
    value: any;
}

// @public (undocumented)
export function shallowClone<T = any>(x: T): T;

// @public
export function toArray<T = any>(src: T | Iterable<T | null | undefined> | null | undefined): T[];

// @public
export function toJsonSafeRaw(raw: any): JSONSafeData;

// @public
export function toRef(value: any): DataNodeRef | undefined;

// (No @packageDocumentation comment for this package)

```
